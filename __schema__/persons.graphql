# import Address from "addresses.graphql"
# import Phone from "phones.graphql"

type Query {
  "the filter must be used to get exactly one person knowing id"
  person(id: ID!): Person

  "the filter should be used in order to get a list of persons by parametrs"
  persons(filter: PersonFilter, orderBy: PersonOrderBy): PersonConnection!
}

input PersonFilter {
  taxId: String
  unzr: String
  phoneNumber: String
  personal: PersonPersonalFilter
}

input PersonPersonalFilter {
  firstName: String!
  lastName: String!
  birthDate: Date! @fake(locale: "uk", method: "date.past", args: [100])
}

enum PersonOrderBy {
  TAX_ID_ASC
  TAX_ID_DESC
  UNZR_ASC
  UNZR_DESC
  BIRTH_DATE_ASC
  BIRTH_DATE_DESC
  INSERTED_AT_ASC
  INSERTED_AT_DESC
}

type PersonConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of nodes."
  nodes: [Person]
  "A list of edges."
  edges: [PersonEdge]
}

type PersonEdge {
  "The item at the end of the edge."
  node: Person!
  "A cursor for use in pagination."
  cursor: String!
}

type Mutation {
  resetPersonAuthenticationMethod(input: ResetPersonAuthenticationMethodInput!): ResetPersonAuthenticationMethodPayload
}

input ResetPersonAuthenticationMethodInput {
  personId: ID!
}

type ResetPersonAuthenticationMethodPayload {
  person: Person!
}

"""
This is Person (MPI) details. In order to obtain details user must have a scope **person:read**
"""
type Person {
  id: ID!
  firstName: String! @fake(locale: "uk", method: "name.firstName", args: [1])
  lastName: String! @fake(locale: "uk", method: "name.lastName", args: [1])
  secondName: String @fake(locale: "uk", method: "name.firstName", args: [0])
  birthDate: Date! @fake(locale: "uk", method: "date.past", args: [100])
  gender: PersonGender!
  status: PersonStatus!
  birthCountry: String!
  birthSettlement: String!
  "the unique number in Unified State Register"
  unzr: String
  taxId: String
    @fake(
      locale: "uk"
      method: "random.number"
      args: [{ min: 1000000000, max: 9999999999 }]
    )
  preferredWayCommunication: PersonPreferredWayCommunication
  insertedAt: DateTime! @fake(locale: "uk", method: "date.past")
  updatedAt: DateTime! @fake(locale: "uk", method: "date.past")
  authenticationMethods: [PersonAuthenticationMethod]!
  documents: [PersonDocument]
  addresses: [Address]!
  "the way how a patient wants to be reached"
  phones: [Phone]
  declarations(
    filter: DeclarationFilter
    orderBy: DeclarationOrderBy
  ): [Declaration]
}

enum PersonStatus {
  ACTIVE
  INACTIVE
}

enum PersonGender {
  MALE
  FEMALE
}

enum PersonPreferredWayCommunication {
  EMAIL
  PHONE
}

type PersonAuthenticationMethod {
  type: PersonAuthenticationMethodType!
  phoneNumber: String
}

enum PersonAuthenticationMethodType {
  OTP
  OFFLINE
  NA
}

type PersonDocument {
  "Dictionary DOCUMENT_TYPE"
  type: String
  "document issue number"
  number: String
  "authority which issued the document"
  issuedBy: String @fake(locale: "uk", method: "company.companyName")
  "the date when document was issued"
  issuedAt: Date @fake(locale: "uk", method: "date.past")
}
