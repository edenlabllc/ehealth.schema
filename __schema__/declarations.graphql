"""
Filters for `Declaration`
"""
input DeclarationFilter {
  "Declaration database identifier."
  declarationId: UUID
  "DEclaration human readable unique number."
  declarationNumber: String
  "DEclaration status"
  status: DeclarationStatus
}

"""
List of fields to filter both ask and desc side `Declaration`.
"""
enum DeclarationOrderBy {
  "Sort declaration by start date in ascending order."
  START_DATE_ASC
  "Sort declaration by start date in descending order."
  START_DATE_DESC
  "Sort declaration by status in ascending order."
  STATUS_ASC
  "Sort declaration by status in descending order."
  STATUS_DESC
}

"""
A connection to a list of `Declaration` values.
"""
type DeclarationConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of nodes."
  nodes: [Declaration]
  "A list of edges."
  edges: [DeclarationEdge]
}

"""
Reads and enables pagination through a set of `Declaration`.
"""
type DeclarationEdge {
  "The item at the end of the edge."
  node: Declaration!
  "A cursor for use in pagination."
  cursor: String!
}

"""
Inputs that should be filled in order to terminate declaration.
"""
input TerminateDeclarationInput {
  "Reads a single `Declaration` using its globally unique ID."
  id: ID!
  "The reason for terminate declaration."
  reasonDescription: String
}

"""
The payload that should be sent in order to terminate declaration.
"""
type TerminateDeclarationPayload {
  "Payload for `declaration`."
  declaration: Declaration!
}

"""
Inputs that should be filled in order to approve declaration.
"""
input ApproveDeclarationInput {
  "Reads a single `Declaration` using its globally unique ID."
  id: ID!
}

"""
The payload that should be sent in order to approve declaration.
"""
type ApproveDeclarationPayload {
  "Payload for `declaration`."
  declaration: Declaration!
}

"""
Inputs that should be filled in order to reject declaration.
"""
input RejectDeclarationInput {
  "Reads a single `Declaration` using its globally unique ID."
  id: ID!
}

"""
The payload that should be sent in order to reject declaration.
"""
type RejectDeclarationPayload {
  "Payload for `declaration`."
  declaration: Declaration!
}

"""
Declaration combines data about Patient, Employee, LegalEntity and Division.

In order to obtain details user must have a scope `declaration:read`.
"""
type Declaration implements Node {
  "The ID of an object"
  id: ID!
  "Primary key identifier from the database"
  databaseId: UUID!
  "unique human redable number of declaration"
  declarationNumber: String!
  "The date when declaration takes effect"
  startDate: Date!
  "The date wher declaration ends."
  endDate: Date!
  "The date when declaration is signed by doctor."
  signedAt: DateTime!
  "Status ah yhe declaration, is set automatically."
  status: DeclarationStatus!
  "type of declaration, as for now it's only one type =`family_doctor`"
  scope: String!
  "ID od declaration request in DB."
  declarationRequestId: UUID!
  "The reason of declining the declaration, is set automatically on declining declaration."
  reason: String
  "Free text for declining declaration, is filled by the person who declined declaration."
  reasonDescription: String
  "Legal entity information, where declaration was signed."
  legalEntity: LegalEntity!
  "Patient information."
  person: Person!
  "Division in legal entity where medical services are provided."
  division: Division!
  "Doctor information, who signed declaration."
  employee: Employee!
}

"""
List of declaration statuses.
"""
enum DeclarationStatus {
  "Status `Active` for declaration."
  ACTIVE
  "Status `PENDING_VERIFICATION` for declaration."
  PENDING_VERIFICATION
  "Status `REJECTED` for declaration."
  REJECTED
  "Status `TERMINATED` for declaration."
  TERMINATED
}

#"""
#Structure of documents attached to the declaration.
#"""
#type DeclarationAttachedDocuments {
#  "The type of document."
#  type: String!
#  "Link for uploading scan copies of the documnet, is generated by e-Health."
#  url: String!
#}
